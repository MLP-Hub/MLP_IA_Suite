# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MLP_IA_Suite
                                 A QGIS plugin
 This plugin contains an end-to-end workflow for analysing terrestrial oblique images 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-12-15
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Claire Wright | Mountain Legacy Project
        email                : claire.wright.mi@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from .interface_tools import addImg

from qgis.PyQt.QtWidgets import QFileDialog
from qgis.core import QgsRasterLayer, QgsProcessing
from qgis import processing

import os.path
import tempfile
import skimage
import cv2
import numpy as np
import math

def createHillshade(dlg):
    """Converts DEM to hillshade"""

    # Read DEM
    DEM_path = os.path.realpath(dlg.InputDEM_lineEdit.text())
    DEM_layer = QgsRasterLayer(DEM_path, "DEM")

    # Set DEM coordinate reference system to NAD83 UTM Zone 12N
    crs = DEM_layer.crs()
    crs.createFromId(26912)
    DEM_layer.setCrs(crs)
        
    # Convert DEM to hillshade and save to temporary file
    parameters = {'INPUT': DEM_layer, 
                    'BAND': 1,
                    'COMPUTE_EDGES': False,
                    'ZEVENBERGEN': False,
                    'Z_FACTOR': 1.0,
                    'SCALE': 1.0,
                    'AZIMUTH': 315,
                    'COMBINED': False,
                    'ALTITUDE': 45,
                    'MULTIDIRECTIONAL': False,
                    'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT}
    
    hillshade=processing.run("gdal:hillshade", parameters)
    dlg.hillshade_path=hillshade['OUTPUT']
    dlg.hillshade_layer = QgsRasterLayer(dlg.hillshade_path, "Hillshade")   

    # Set hillshade coordinate reference system to NAD83 UTM Zone 12N
    crs = dlg.hillshade_layer.crs()
    crs.createFromId(26912)
    dlg.hillshade_layer.setCrs(crs)


def readCamParams(dlg):
    """Reads user input camera parameters as dictionary"""

    cam_params = {}

    # Get camera parameters from user input
    cam_params["lat"] = float(dlg.Easting_lineEdit.text())
    cam_params["lon"] = float(dlg.Northing_lineEdit.text())
    cam_params["azi"] = float(dlg.Azi_lineEdit.text())
    cam_params["v_fov"] = float(dlg.vertFOV_lineEdit.text())
    cam_params["h_fov"] = float(dlg.horFOV_lineEdit.text())
    cam_params["ray_len"] = float(dlg.Ext_lineEdit.text())*1000
    cam_params["hgt"] = float(dlg.CamHgt_lineEdit.text())
    
    if dlg.Elev_lineEdit.text() == "":
        cam_params["elev"] = None
    else:
        cam_params["elev"] = float(dlg.Elev_lineEdit.text()) # if user specified elevation, read it
        

    # find image height and width
    img_path = dlg.InputRefImg_lineEdit.text()
    ref_img = cv2.imread(img_path) # read the reference image
    h, w, *_ = ref_img.shape # get image dimensions
    cam_params["img_h"] = h
    cam_params["img_w"] = w
    
    return cam_params

def camXY(dlg, lat, lon):
    """Determines pixel coordinates of camera position"""

    # get hillshade extents and spatial resolution
    ex = dlg.hillshade_layer.extent() 
    pixelSizeX = dlg.hillshade_layer.rasterUnitsPerPixelX()
    pixelSizeY = dlg.hillshade_layer.rasterUnitsPerPixelY()

    # if pixelSizeX != pixelSizeY --> error
    
    # get top left coordinate
    ymax = ex.yMaximum()
    xmin = ex.xMinimum() 

    # get camera position in pixel coordinates
    cam_x = int((lat - xmin)/pixelSizeX)
    cam_y = int((ymax - lon)/pixelSizeY)

    return cam_x, cam_y, pixelSizeX, pixelSizeY

def createVP(dlg):
    """Creates virtual photograph""" 
    
    DEM_path = os.path.realpath(dlg.InputDEM_lineEdit.text())
    DEM_img = skimage.io.imread(DEM_path) # read DEM into image array
    HS_img = cv2.imread(dlg.hillshade_path) # read hillshade into image array
    
    cam_params = readCamParams(dlg) # read camera parameters
    cam_x, cam_y, pixelSizeX, pixelSizeY = camXY(dlg, cam_params["lat"], cam_params["lon"]) # find pixel coordinates of camera position and raster resolution
    
    if cam_params["elev"] is None:
        cam_params["elev"] = DEM_img[cam_y, cam_x] # read elevation from DEM if not provided by user

    
    img = np.zeros((cam_params["img_h"],cam_params["img_w"]),dtype=np.uint8) # create blank image

    a = cam_params["azi"] - cam_params["h_fov"]/2 # starting ray angle is azimuth minus half of horizontal FOV
    
    pic_angles = np.linspace(-cam_params["v_fov"]/2, cam_params["v_fov"]/2, cam_params["img_h"]) # create list of image angles
    pic_angles = np.tan(np.radians(pic_angles)) # find ratio (opp/adj)

    # create ray start position (remove first 100 m)
    ray_start_y = int(cam_y - (100*math.cos(np.radians(a))/pixelSizeX))
    ray_start_x = int(cam_x + (100*math.sin(np.radians(a))/pixelSizeY))

    for img_x in range(0,cam_params["img_w"]):
            
        # create ray end position
        ray_end_y = int(cam_y - (cam_params["ray_len"]*math.cos(np.radians(a))/pixelSizeX))
        ray_end_x = int(cam_x + (cam_params["ray_len"]*math.sin(np.radians(a))/pixelSizeY))
 
        rr, cc = skimage.draw.line(ray_start_y, ray_start_x, ray_end_y, ray_end_x) # create a ray

        val = DEM_img[rr, cc] - (cam_params["elev"]+cam_params["hgt"]) # get array of elevations
        ll = np.sqrt((abs(rr-cam_y)*pixelSizeY)**2 + (abs(cc-cam_x)*pixelSizeX)**2) # create a list of angles of view for the DEM
        dem_angles = np.divide(val,ll) # find ratio (opp/adj)

        dem_angles_inc = np.maximum.accumulate(dem_angles) # checks for only increasing DEM angles
        unique_angles, unique_angles_indx = np.unique(dem_angles_inc, return_index=True) # keep only unique increasing angles and their index
            
        # find rows and columns of increasing unique angles
        rr_new = rr[unique_angles_indx]
        cc_new = cc[unique_angles_indx]

        greyscale_vals = HS_img[rr_new, cc_new][:,0] # extract greyscale values at specified rows and columns

        nonsky_pixels = pic_angles[pic_angles < max(dem_angles_inc)] # truncate picture array to remove sky pixels

        yinterp = np.interp(nonsky_pixels, unique_angles, greyscale_vals) # interpolate any missing greyscale values

        img_column = np.concatenate((yinterp, np.ones(cam_params["img_h"] - len(yinterp)) * 255)) # create column for image and fill sky pixels white

        img[:, img_x] = np.flip(img_column, axis=0) # flip the column
            
        a = a+(cam_params["h_fov"]/cam_params["img_w"]) # update ray angle

    return img

def enableTools(dlg):
    """Enables canvas tools once canvas is populated with mask and image"""

    dlg.View_toolButton_2.setEnabled(True)
    dlg.Fit_toolButton_2.setEnabled(True)
    dlg.Pan_toolButton_2.setEnabled(True)
    dlg.FullScrn_toolButton_2.setEnabled(True)

def displaySaveVP(dlg, save):
    """Displays and saves virtual photo"""

    if save:
        # open save dialog and save vp
        vp_path = QFileDialog.getSaveFileName(filter = "TIFF format (*.tiff *.TIFF)")[0]
    else:
        # save vp to temp path
        vp_path = os.path.join(tempfile.mkdtemp(), 'tempVP.tiff')

    vp = createVP(dlg) # creates virtual photo
    cv2.imwrite(vp_path, vp)

    addImg(dlg.InputRefImg_lineEdit.text(),"Original Image",dlg.Img_mapCanvas_2) # show input image in side-by-side
    addImg(vp_path,"Virtual Photo",dlg.VP_mapCanvas) # show output mask in side-by-side
    addImg(vp_path,"Virtual Photo",dlg.Full_mapCanvas_2) # show output mask in fullview
    addImg(dlg.InputRefImg_lineEdit.text(),"Original Image",dlg.Full_mapCanvas_2) # show input image in full view
    
    enableTools(dlg)
