# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MLP_IA_Suite
                                 A QGIS plugin
 This plugin contains an end-to-end workflow for analysing terrestrial oblique images 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-12-15
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Claire Wright | Mountain Legacy Project
        email                : claire.wright.mi@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.gui import QgsMapToolEmitPoint
from qgis.core import QgsVectorLayer, QgsField, QgsProject, QgsFeature, QgsGeometry, QgsMarkerSymbol
from PyQt5.QtCore import Qt, QVariant


def createCPLayer(canvas, lyr_name):
    """Creates a temporary vector layer to receive CPs"""

    img_layer = QgsProject.instance().mapLayersByName("Source Image")[0]

    img_crs = img_layer.crs()

    vl = QgsVectorLayer("Point", lyr_name, "memory") # create new vector layer
    vl.setCrs(img_crs)
    pr = vl.dataProvider()
    vl.startEditing() # enter editing mode
    pr.addAttributes( [ QgsField("X", QVariant.Double), QgsField("Y",  QVariant.Double)] ) # add fields for X and Y coords
    vl.commitChanges() # commit changes

    symbol = QgsMarkerSymbol.createSimple({'color': 'red'})
    # apply symbol to layer renderer
    vl.renderer().setSymbol(symbol)

    QgsProject.instance().addMapLayer(vl, False) # add vector layer to the registry (but don't load into main map)

    # add layer to the provided canvas
    layer_list = canvas.layers()
    #layer_list.append(vl)
    layer_list.insert(0, vl)
    canvas.setLayers(layer_list)
    canvas.refreshAllLayers()

def add_cp(point, canvas, name):
    """Adds CP (from mouse click) to vector layer"""

    vl = QgsProject.instance().mapLayersByName(name)[0] # get CP vector layer

    # add new cp to vector layer
    vl.startEditing() # enter editing mode
    pr = vl.dataProvider()
    fet = QgsFeature()
    fet.setGeometry(QgsGeometry.fromPointXY(point))
    fet.setAttributes([point.x(),point.y()])
    pr.addFeatures([fet])
    vl.commitChanges() # commit changes
    vl.triggerRepaint() # repaint the layer
    canvas.refreshAllLayers()
    #canvas.setExtent(vl.extent())

def selectCP(dlg, canvas, name):
    """Allows user to select control point"""

    # check if vector layer of CPs exists, otherwise create one
    layer_list = canvas.layers()

    lyr_ids = {}
    for lyr in layer_list:
        lyr_ids[lyr.name()] = lyr.id()
    if name not in lyr_ids:
       createCPLayer(canvas, name) 

    dlg.CPtool = QgsMapToolEmitPoint(canvas)
    dlg.CPtool.canvasClicked.connect(lambda point: add_cp(point, canvas, name))
    dlg.CPtool.setCursor(Qt.CrossCursor)
    #button.enable() # send to other function that makes sure only one tool is active
    canvas.setMapTool(dlg.CPtool)





