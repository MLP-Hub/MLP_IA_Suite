# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MLP_IA_Suite
                                 A QGIS plugin
 This plugin contains an end-to-end workflow for analysing terrestrial oblique images 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-12-15
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Claire Wright | Mountain Legacy Project
        email                : claire.wright.mi@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import numpy as np
import scipy
import skimage
import tempfile

from qgis.core import QgsRasterLayer, QgsProcessing, QgsProject, QgsRasterFileWriter, QgsRasterPipe
from qgis.PyQt.QtWidgets import QFileDialog, QProgressDialog
from PyQt5.QtCore import Qt
from qgis import processing

from .interface_tools import errorMessage,  loadLayer

def addLayer(filter_string, listWidget):
    """Users provides raster layer to add to list"""

    dialog = QFileDialog()
    dialog.setFileMode(QFileDialog.ExistingFiles)
    dialog.setOption(dialog.DontUseNativeDialog)
    dialog.setNameFilter(filter_string)

    if dialog.exec_():
        filepaths = dialog.selectedFiles() # get user selected file(s)
        for filepath in filepaths:
            match = listWidget.findItems(filepath,Qt.MatchExactly) # check to ensure filepath doesn't exist already
            if len(match) == 0:
                listWidget.addItem(filepath) # if not a duplicate, add filepath to list

def removeLayer(listWidget):
    """Removes selected layer from layer list"""

    row = listWidget.currentRow()
    listWidget.takeItem(row)

def moveLayerUp(listWidget):
    """Moves layer up in list"""

    currentRow = listWidget.currentRow()
    currentItem = listWidget.takeItem(currentRow)
    listWidget.insertItem(currentRow - 1, currentItem)

def moveLayerDown(listWidget):
    """Moves layer down in list"""

    currentRow = listWidget.currentRow()
    currentItem = listWidget.takeItem(currentRow)
    listWidget.insertItem(currentRow + 1, currentItem)

def readRasterLayers(listWidget):
    """Reads filepaths from list and finds extents, resolutions, and checks CRS for each layer"""

    filepaths = [listWidget.item(x).text() for x in range(listWidget.count())] # get list of filepaths from input

    min_xs = []
    max_xs = []
    min_ys = []
    max_ys = []

    # check original CRS and resolution
    good_path = os.path.realpath(filepaths[0])
    raster_layer = QgsRasterLayer(good_path, os.path.basename(good_path))
    ref_crs = raster_layer.crs() # get current CRS
    refResX = round(raster_layer.rasterUnitsPerPixelX())
    refResY = round(raster_layer.rasterUnitsPerPixelY())

    for filepath in filepaths:

        # first convert to raster layer
        good_path = os.path.realpath(filepath)
        raster_layer = QgsRasterLayer(good_path, os.path.basename(good_path))

        # check layer CRS (all must be the same CRS and in meters)
        if raster_layer.crs() != ref_crs:
            errorMessage("All inputs must be in the same coordinate reference systems")
            return
        
        # check layer resolution (must be the same)
        if  round(raster_layer.rasterUnitsPerPixelX()) != refResX or round(raster_layer.rasterUnitsPerPixelY()) != refResY:
            errorMessage("All inputs must have in the same spatial resolution")
            return

        ex = raster_layer.extent()
        min_xs.append(ex.xMinimum())
        max_xs.append(ex.xMaximum())
        min_ys.append(ex.yMinimum())
        max_ys.append(ex.yMaximum())

    extents = [min_xs, max_xs, min_ys, max_ys]

    return filepaths, extents, refResX, refResY

def pad_arrays(filepaths, extents, res_x, res_y):
    """Pads all input arrays based on max combined extents"""

    input_arrays = []

    for i, filepath in enumerate(filepaths):
        
        # read image into array
        img = skimage.io.imread(os.path.realpath(filepath), as_gray=True)

        # pad array with NaN values so that all inputs have same size

        before_y = int((extents[2][i] - min(extents[2]))/res_y)
        after_y = int((max(extents[3]) - extents[3][i])/res_y)

        before_x = int((max(extents[1]) - extents[1][i])/res_x)
        after_x = int((extents[0][i] - min(extents[0]))/res_x)
        
        pad_width = ((before_y, after_y), (before_x, after_x))

        img_pad = np.pad(img.astype(np.float), pad_width, mode='constant', constant_values=np.nan)

        img_pad[img_pad == 0] = np.nan # convert zeros to NaN as well

        input_arrays.append(img_pad)

    return input_arrays

def rankedMosaic(input_arrays):
    """Mosaics a set of rasters based on mode"""

    mosaic = scipy.stats.mode(input_arrays, axis = 0, nan_policy = 'omit')[0] # find mode
    mosaic = mosaic.astype(np.int)

    return mosaic

# def probMosaic(input_arrays, input_probs):
    # """Mosaics a set of rasters based on classification probability"""

    # # create large raster using max extents of all inputs, add 8 channels for 8 LC types
    # master = np.zeros((input_arrays[0].shape[0],input_arrays[0].shape[1], 8),dtype=np.float64)

    # rows = master.shape[0]
    # cols = master.shape[1]

    # progressDlg = QProgressDialog("Creating viewshed...","Cancel", 0, rows)
    # progressDlg.setWindowModality(Qt.WindowModal)
    # progressDlg.setValue(0)
    # progressDlg.forceShow()
    # progressDlg.show() 

    # for i in range(0, rows):
    #     progressDlg.setValue(i)
    #     for j in range(0, cols):
    #         for k, array in enumerate(input_arrays):
    #             lc_class = array[i,j]
    #             if np.isnan(lc_class):
    #                 break
    #             lc_class = int(lc_class)
    #             val = input_probs[k][i,j]
    #             if np.isnan(val):
    #                 break
    #             master[i:j:lc_class]+=val
    
    # mosaic = np.argmax(master, axis = 0)

    # return mosaic

def probMosaic(input_arrays, input_probs):
    """Mosaics a set of rasters based on classification probability"""

    n = 8 # number of unique LC classes
    master = np.zeros((input_arrays[0].shape[0],input_arrays[0].shape[1], n),dtype=np.float64)

    for i, array in enumerate(input_arrays):
        for lc in range(1,n+1):
            lc_index = np.where(array==lc)
            probs = input_probs[i]
            lc_probs = probs[lc_index]
            #print(lc_probs)

            master[lc_index[0],lc_index[1],lc-1]+=lc_probs

    #print(master)
    mosaic = np.argmax(master, axis = 2)
    #print(mosaic)

    return mosaic

        
        




def createMosaicLayer(mosaic_path, extents):
    """Converts mosaic image to useable layer"""
 
    ext_list = ["-a_ullr",str(min(extents[0])),str(max(extents[3])),str(max(extents[1])), str(min(extents[2]))]
    ullr = " ".join(ext_list)

    PARAMS = { 'COPY_SUBDATASETS' : False, 
              'DATA_TYPE' : 0, 
              'EXTRA' : ullr, 
              'INPUT' : mosaic_path, 
              'NODATA' : "0", 
              'OPTIONS' : '', 
              'OUTPUT' : QgsProcessing.TEMPORARY_OUTPUT, 
              'TARGET_CRS' : None }

    mosaic_ref=processing.run("gdal:translate", PARAMS)

    mosaic_ref_path=mosaic_ref['OUTPUT']
    mosaic_layer = QgsRasterLayer(mosaic_ref_path, "Mosaic")

    return mosaic_ref_path, mosaic_layer  

def mosaicRasters(listWidget, ranking_checkBox, dlg):
    """Mosaics provided rasters together"""

    filepaths, extents, res_x, res_y = readRasterLayers(listWidget) # read all layers from list

    input_arrays = pad_arrays(filepaths, extents, res_x, res_y) # pad all inputs to max extents

    if ranking_checkBox.isChecked():
        mosaic_img = rankedMosaic(input_arrays) # mosaic the input arrays based on mode
    else:
        prob_paths = []
        for path in filepaths:
            raster_path, ext = os.path.splitext(path)
            prob_paths.append(os.path.join(raster_path + '_probs.tiff'))
            input_probs = pad_arrays(prob_paths, extents, res_x, res_y)
        mosaic_img = probMosaic(input_arrays, input_probs) # mosaic the input arrays based on PyLC probability

    if mosaic_img is None:
        # break if mosaicking did not work
        errorMessage("Mosaicking failed.")
        return

    # save mosaicked image to temp path
    dlg.mosaic_path = os.path.join(tempfile.mkdtemp(), 'tempMosaic.tiff')
    if os.path.isfile(dlg.mosaic_path):
        # check if the temporary file already exists
        os.remove(dlg.mosaic_path)

    skimage.io.imsave(dlg.mosaic_path, mosaic_img) # write mosaic to image

    dlg.mosaic_path, mosaic_ref_layer = createMosaicLayer(dlg.mosaic_path, extents) # convert mosaic from image to referenced raster layer

    QgsProject.instance().addMapLayer(mosaic_ref_layer, False) # add layer to the registry (but don't load into main map)
    
    dir_path = os.path.dirname(__file__)
    dir_path = os.path.normpath(dir_path)
    style_path = os.path.join(dir_path, "sb_PyLC_style.qml") # path to file containing layer style

    mosaic_ref_layer.loadNamedStyle(style_path)

    #remove any existing layers, then add mosaic to map
    layer_list = dlg.Mosaic_mapCanvas.layers()
    for lyr in layer_list:
        QgsProject.instance().removeMapLayer(lyr.id()) # if the layer already exists, remove it from the canvas
    loadLayer(dlg.Mosaic_mapCanvas, mosaic_ref_layer)


def saveMosaic(dlg):
    """Saves mosaic to specified location"""

    mosaic = QgsRasterLayer(dlg.mosaic_path)
    save_mosaic_path = None

    # open save dialog 
    dialog = QFileDialog()
    dialog.setOption(dialog.DontUseNativeDialog)
    dialog.setNameFilter("TIFF format (*.tiff *.TIFF)")
    dialog.setDefaultSuffix("tiff")
    dialog.setAcceptMode(QFileDialog.AcceptSave)

    if dialog.exec_():
        save_mosaic_path = dialog.selectedFiles()[0]

        # get CRS from first layer in list
        filepath = os.path.realpath(dlg.layers_listWidget.item(0).text())
        ref_layer = QgsRasterLayer(filepath, "ref")
        dest_crs = ref_layer.crs()


        # write moasic to raster file
        file_writer = QgsRasterFileWriter(save_mosaic_path)
        pipe = QgsRasterPipe()
        provider = mosaic.dataProvider()
        ctc=QgsProject.instance().transformContext()

        if not pipe.set(provider.clone()):
            errorMessage("Cannot set pipe provider")

        file_writer.writeRaster(
            pipe,
            provider.xSize(),
            provider.ySize(),
            provider.extent(),
            dest_crs, ctc)