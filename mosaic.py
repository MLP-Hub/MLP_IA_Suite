# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MLP_IA_Suite
                                 A QGIS plugin
 This plugin contains an end-to-end workflow for analysing terrestrial oblique images 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-12-15
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Claire Wright | Mountain Legacy Project
        email                : claire.wright.mi@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import numpy as np
import scipy
import skimage
import cv2
import tempfile

from qgis.core import QgsRasterLayer, QgsProject, QgsRasterFileWriter, QgsRasterPipe, QgsProcessingFeedback
from qgis.PyQt.QtWidgets import QFileDialog, QProgressDialog
from PyQt5.QtCore import Qt
from qgis import processing

from .interface_tools import errorMessage,  loadLayer

def addLayer(filter_string, listWidget):
    """Users provides raster layer to add to list"""

    dialog = QFileDialog()
    dialog.setFileMode(QFileDialog.ExistingFiles)
    dialog.setOption(dialog.DontUseNativeDialog)
    dialog.setNameFilter(filter_string)

    if dialog.exec_():
        filepaths = dialog.selectedFiles() # get user selected file(s)
        for filepath in filepaths:
            match = listWidget.findItems(filepath,Qt.MatchExactly) # check to ensure filepath doesn't exist already
            if len(match) == 0:
                listWidget.addItem(filepath) # if not a duplicate, add filepath to list

def removeLayer(listWidget):
    """Removes selected layer from layer list"""

    row = listWidget.currentRow()
    listWidget.takeItem(row)

def moveLayerUp(listWidget):
    """Moves layer up in list"""

    currentRow = listWidget.currentRow()
    currentItem = listWidget.takeItem(currentRow)
    listWidget.insertItem(currentRow - 1, currentItem)
    listWidget.setCurrentRow(listWidget.currentRow() - 2)

def moveLayerDown(listWidget):
    """Moves layer down in list"""

    currentRow = listWidget.currentRow()
    currentItem = listWidget.takeItem(currentRow)
    listWidget.insertItem(currentRow + 1, currentItem)
    listWidget.setCurrentRow(listWidget.currentRow() + 2)

def readRasterLayers(listWidget):
    """Reads filepaths from list and finds extents, resolutions, and checks CRS for each layer"""

    filepaths = [listWidget.item(x).text() for x in range(listWidget.count())] # get list of filepaths from input

    # check original CRS and resolution
    good_path = os.path.realpath(filepaths[0])
    raster_layer = QgsRasterLayer(good_path, os.path.basename(good_path))
    ref_crs = raster_layer.crs() # get current CRS
    refResX = round(raster_layer.rasterUnitsPerPixelX())
    refResY = round(raster_layer.rasterUnitsPerPixelY())

    for filepath in filepaths:

        # first convert to raster layer
        good_path = os.path.realpath(filepath)
        raster_layer = QgsRasterLayer(good_path, os.path.basename(good_path))

        # check layer CRS (all must be the same CRS and in meters)
        if raster_layer.crs() != ref_crs:
            errorMessage("All inputs must be in the same coordinate reference system")
            return
        
        # check layer resolution (must be the same)
        if  round(raster_layer.rasterUnitsPerPixelX()) != refResX or round(raster_layer.rasterUnitsPerPixelY()) != refResY:
            errorMessage("All inputs must have in the same spatial resolution")
            return

    return filepaths
    """Uses GRASS r.series to find mode"""

    PARAMS = {
     'input' : input_layers,
     'output' : 'TEMPORARY_OUTPUT',
     '-n' : False,
     'method' : [3]
       }

    # Run algorithm
    mode_mosaic = processing.run('grass7:r.series', PARAMS)  

    mode_mosaic_path=mode_mosaic['output']

    return mode_mosaic_path

def gdalModeMosaic(input_layers):
    """Uses GDAL Build VRT to find mode"""

    parameters = {'INPUT':input_layers,
                    'RESOLUTION':0,
                    'SEPARATE':False,
                    'PROJ_DIFFERENCE':False,
                    'ADD_ALPHA':False,
                    'ASSIGN_CRS':None,
                    'RESAMPLING':6,
                    'SRC_NODATA':'',
                    'EXTRA':'',
                    'OUTPUT':'TEMPORARY_OUTPUT'}
    
    try:
        mode_mosaic=processing.run("gdal:buildvirtualraster", parameters)

        mode_mosaic_path=mode_mosaic['OUTPUT']
    except:
        errorMessage("Mosaicking failed")
    
    return mode_mosaic_path

def addProbs(input_layers):
    "Add together raster layers using GRASS r.series"

    PARAMS = {
     'input' : input_layers,
     'output' : 'TEMPORARY_OUTPUT',
     '-n' : False,
     'method' : [10]
       }

    # Run algorithm
    summed_probs = processing.run('grass7:r.series', PARAMS)  

    summed_probs_path=summed_probs['output']

    return summed_probs_path

def probMosaic(input_lyrs, input_probs):
    """Mosaics a set of rasters based on classification probability"""

    n_classes = 9 # number of unique LC classes

    all_class_probs = []

    for n in range(1, n_classes + 1):
    # loop through each land cover class

        class_spec_probs = [] # initiate list to hold the masked class-specific probabilities for each input raster

        for i, class_path in enumerate(input_lyrs):
        # loop through each input raster and associated probability

            # use raster calculator to mask probabilities based on class value in the lc raster
            formula = f"(A == {n}) * B"
            PARAMS = {'INPUT_A' : class_path,
                        'INPUT_B' : input_probs[i],
                        'BAND_A' : 1,
                        'BAND_B' : 1,
                        'NO_DATA':0,
                        'FORMULA' : formula,
                        'OUTPUT' : 'TEMPORARY_OUTPUT'}

            masked_probs = processing.run('gdal:rastercalculator', PARAMS)
            
            class_spec_probs.append(masked_probs['OUTPUT'])  
        
        all_class_probs.append(addProbs(class_spec_probs)) # sum class specific probabilites across all input rasters

    # find max probability at each pixel and return the associated class
    PARAMS = {
     'input' : all_class_probs,
     'output' : 'TEMPORARY_OUTPUT',
     '-n' : False,
     'method' : [7]
       }

    # Run algorithm
    max_probs_class = processing.run('grass7:r.series', PARAMS)  

    max_probs_class_path=max_probs_class['output']

    # Add one to output
    formula = "A + 1"
    parameters = {'INPUT_A' : max_probs_class_path,
                'BAND_A' : 1,
                'FORMULA' : formula,
                'OUTPUT' : 'TEMPORARY_OUTPUT'}

    probs_mosaic = processing.run('gdal:rastercalculator', parameters)
    
    probs_mosaic_path = probs_mosaic['OUTPUT']  
    
    return probs_mosaic_path
       
def mosaicRasters(listWidget, ranking_checkBox, dlg):
    """Mosaics provided rasters together"""

    input_raster_paths = readRasterLayers(listWidget) # read all layers from list

    if ranking_checkBox.isChecked():
       paths_reversed = input_raster_paths[::-1] # reverse order for mosaic
       dlg.mosaic_path = gdalModeMosaic(paths_reversed)
    
    else:
        prob_paths = []
        for path in input_raster_paths:
            raster_path, ext = os.path.splitext(path)
            prob_path = os.path.join(raster_path + '_probs.tiff')
            if os.path.isfile(prob_path):
                prob_paths.append(prob_path)
            else:
                errorMessage("Missing probability file. \n"+prob_path+" does not exist.\n Use ranked mosaic instead.")
                return
        
        dlg.mosaic_path = probMosaic(input_raster_paths, prob_paths)

    mosaic_ref_layer = QgsRasterLayer(dlg.mosaic_path, "Mosaic")

    QgsProject.instance().addMapLayer(mosaic_ref_layer, False) # add layer to the registry (but don't load into main map)
    
    dir_path = os.path.dirname(__file__)
    dir_path = os.path.normpath(dir_path)
    style_path = os.path.join(dir_path, "sb_PyLC_style.qml") # path to file containing layer style

    mosaic_ref_layer.loadNamedStyle(style_path)

    #remove any existing layers, then add mosaic to map
    layer_list = dlg.Mosaic_mapCanvas.layers()
    for lyr in layer_list:
        QgsProject.instance().removeMapLayer(lyr.id()) # if the layer already exists, remove it from the canvas
    loadLayer(dlg.Mosaic_mapCanvas, mosaic_ref_layer)

def saveMosaic(dlg):
    """Saves mosaic to specified location"""

    mosaic = QgsRasterLayer(dlg.mosaic_path)
    save_mosaic_path = None

    # open save dialog 
    dialog = QFileDialog()
    dialog.setOption(dialog.DontUseNativeDialog)
    dialog.setNameFilter("TIFF format (*.tiff *.TIFF)")
    dialog.setDefaultSuffix("tiff")
    dialog.setAcceptMode(QFileDialog.AcceptSave)

    if dialog.exec_():
        save_mosaic_path = dialog.selectedFiles()[0]

        # get CRS from first layer in list
        filepath = os.path.realpath(dlg.layers_listWidget.item(0).text())
        ref_layer = QgsRasterLayer(filepath, "ref")
        dest_crs = ref_layer.crs()


        # write moasic to raster file
        file_writer = QgsRasterFileWriter(save_mosaic_path)
        pipe = QgsRasterPipe()
        provider = mosaic.dataProvider()
        ctc=QgsProject.instance().transformContext()

        if not pipe.set(provider.clone()):
            errorMessage("Cannot set pipe provider")

        file_writer.writeRaster(
            pipe,
            provider.xSize(),
            provider.ySize(),
            provider.extent(),
            dest_crs, ctc)