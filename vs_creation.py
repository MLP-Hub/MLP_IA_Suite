# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MLP_IA_Suite
                                 A QGIS plugin
 This plugin contains an end-to-end workflow for analysing terrestrial oblique images 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-12-15
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Claire Wright | Mountain Legacy Project
        email                : claire.wright.mi@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import skimage
import numpy as np
import math
import scipy
import cv2

def initCamParams():
    """Read initial camera parameters from text file"""

    cam_filepath = "C:\Thesis\WLNP_test_cam_params.txt"

    cam_file = open(cam_filepath, "r")

    cam_params = {}

    for line in cam_file:
        (key, val) = line.split(":")
        cam_params[key] = val
        if cam_params[key] != 'None\n':
            cam_params[key] = float(val)
        else:
            cam_params[key]=None # set elevation to None

    return cam_params

def closest_argmin(A, B):
    """Finds closest matches between two arrays"""
    L = B.size
    sidx_B = B.argsort()
    sorted_B = B[sidx_B]
    sorted_idx = np.searchsorted(sorted_B, A)
    sorted_idx[sorted_idx==L] = L-1
    mask = (sorted_idx > 0) & \
    ((np.abs(A - sorted_B[sorted_idx-1]) < np.abs(A - sorted_B[sorted_idx])) )
    return sorted_idx-mask

def drawViewshed():
    """Get real world coordinates for each pixel in the mask"""

    cam_params = initCamParams()

    DEM_path = "C:\Thesis\dem_5m_mtblakiston.tiff"
    DEM_img = skimage.io.imread(DEM_path) # read clipped DEM into image array
    dem_h, dem_w, *_ = DEM_img.shape

    mask_path = "C:\Thesis\mask_test.png"
    mask = cv2.imread(mask_path)

    img_h, img_w, *_ = mask.shape
    #cam_x, cam_y, pixelSizeX, pixelSizeY = camXY(dlg.hs_layer, cam_params["lat"], cam_params["lon"]) # find pixel coordinates of camera position and raster resolution
    cam_x, cam_y, pixelSizeX, pixelSizeY = 943, 2486, 5.0, 5.0
    v_fov = cam_params["h_fov"]*img_h/img_w # determine vertical field of view from horizontal field of view and picture size
    
    if cam_params["elev"] is None:
        cam_params["elev"] = DEM_img[cam_y, cam_x] # read elevation from DEM if not provided by user

    vs = np.zeros((dem_h,dem_w, 3),dtype=np.uint8) # create blank viewshed (same size as DEM)

    a = cam_params["azi"] - cam_params["h_fov"]/2 # starting ray angle is azimuth minus half of horizontal FOV
    
    img_v_angles = np.linspace(-v_fov/2, v_fov/2, img_h) # create list of image angles
    img_v_angles = np.tan(np.radians(img_v_angles)) # find ratio (opp/adj)

    for img_x in range(0, img_w):
        # First, find all visible pixles
        # get the horizontal and vertical angles to the camera position
        # and find the corresponding greyscale values

        # create ray start position (remove first 100 m)
        ray_start_y = cam_y - (100*math.cos(np.radians(a))/pixelSizeY)
        ray_start_x = cam_x + (100*math.sin(np.radians(a))/pixelSizeX)
        
        # create ray end position
        ray_end_y = cam_y - (25000*math.cos(np.radians(a))/pixelSizeY)
        ray_end_x = cam_x + (25000*math.sin(np.radians(a))/pixelSizeX)

        xs = np.linspace(ray_start_x, ray_end_x, round(25000/pixelSizeX))
        ys = np.linspace(ray_start_y, ray_end_y, round(25000/pixelSizeY))

        elevs = scipy.ndimage.map_coordinates(DEM_img, np.vstack((ys,xs)), order = 1) - cam_params["elev"]+cam_params["hgt"]

        opp = (xs - cam_x)*pixelSizeX
        adj = (cam_y - ys)*pixelSizeY

        dem_dist = np.sqrt(np.add(opp**2, adj**2))
        vert_angles = np.divide(elevs,dem_dist) # find ratio (opp/adj)

        dem_angles_inc = np.fmax.accumulate(vert_angles) # checks for only increasing DEM angles
        unique_angles, unique_angles_indx = np.unique(dem_angles_inc, return_index=True) # keep only unique increasing angles and their index

        xs_visible = xs[unique_angles_indx].astype(int) # keep only visible x-coordinates
        ys_visible = ys[unique_angles_indx].astype(int) # keep only visible y-coordinates

        angle_matches_index = closest_argmin(unique_angles, img_v_angles)
        mask_col = mask[:,img_x] # get column from mask
        mask_col = np.flip(mask_col, axis=0) # reverse order of pixels
        mask_col = mask_col[angle_matches_index] # keep only the non-sky pixels

        vs[ys_visible, xs_visible] = mask_col
            
        a = a+(cam_params["h_fov"]/img_w) # update ray angle

    #vs = np.rot90(vs, 2)
    cv2.imwrite("C:\\Thesis\\test_vs.tiff", vs)


if __name__ == "__main__":
    drawViewshed()