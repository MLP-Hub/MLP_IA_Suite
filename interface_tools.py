# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MLP_IA_Suite
                                 A QGIS plugin
 This plugin contains an end-to-end workflow for analysing terrestrial oblique images 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-12-15
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Claire Wright | Mountain Legacy Project
        email                : claire.wright.mi@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtWidgets import QFileDialog
from qgis.core import QgsRasterLayer, QgsProject, QgsRasterTransparency
from qgis.gui import QgsMapToolPan

from .swipe_tool import mapswipetool

import os.path

def setScaleBoxVal(dlg, val):
    """Changes scale box value based on slider"""

    val = float(val / 10)
    val = str(val)
    dlg.Scale_lineEdit.setText(val)

def setScaleSlideVal(dlg, val):
    """Changes scale slider value based on text box"""

    val = float(val)
    val = int(val*10)
    dlg.Scale_slider.setValue(val)

def getFileFolder(lineEdit):
    """Allows user to select image file or folder"""

    def _selected(name):
        """Changes file mode depending on whether current selection is a file or a folder"""

        if os.path.isdir(name):
            dialog.setFileMode(QFileDialog.Directory)
        else:
            dialog.setFileMode(QFileDialog.ExistingFile)
            dialog.setNameFilter("JPG format (*.jpg);;TIF format (*.tif *.TIF)")

  
    dialog = QFileDialog()
    dialog.setFileMode(dialog.ExistingFiles)
    dialog.setOption(dialog.DontUseNativeDialog)
    dialog.currentChanged.connect(_selected) #if selection changes from file to folder
        
    dialog.exec_()

    filepath = dialog.selectedFiles()
    lineEdit.setText(filepath[0])

def getFolder(lineEdit):
    """Select folder (usually output directory)"""

    dialog = QFileDialog()
    dialog.setFileMode(QFileDialog.Directory)
    dialog.setOption(dialog.DontUseNativeDialog)

    dialog.exec_()
    filepath = dialog.selectedFiles()[0]
    lineEdit.setText(filepath)

def getFile(lineEdit, filter_string):
    """Select file"""

    dialog = QFileDialog()
    dialog.setFileMode(QFileDialog.ExistingFile)
    dialog.setOption(dialog.DontUseNativeDialog)
    dialog.setNameFilter(filter_string)

    dialog.exec_()
    filepath = dialog.selectedFiles()[0]
    lineEdit.setText(filepath)

def addImg(filepath, name, canvas):
    """Adds provided image in map canvas"""

    layer_list = canvas.layers()

    lyr_ids = {}
    for lyr in layer_list:
        lyr_ids[lyr.name()] = lyr.id()
    if name in lyr_ids:
        QgsProject.instance().removeMapLayer(lyr_ids[name]) # if the layer already exists, remove it from the canvas
        
    img_lyr= QgsRasterLayer(filepath, name)
    # Load mask as layer into mask map canvas
    QgsProject.instance().addMapLayer(img_lyr, False) # add layer to the registry (but don't load into main map)
    canvas.enableAntiAliasing(True)
    canvas.setExtent(img_lyr.extent()) # set extent to the extent of the image layer
    layer_list = canvas.layers()
    layer_list.append(img_lyr)
    canvas.setLayers(layer_list)

def updateExtents(canvas, ref_canvas):
    """Updates the extent of a map canvas to match a reference canvas"""

    if canvas.extent() != ref_canvas.extent():
        canvas.setExtent(ref_canvas.extent())
        canvas.refresh()

def panCanvas(dlg, canvas_list, pan_button):
    """Enables/disables pan tool for provided map canvas(es)"""
    dlg.pan_tools = []

    # create pan tools for each canvas
    for canvas in canvas_list:
        dlg.pan_tools.append(QgsMapToolPan(canvas))
    
    # set map tool for each canvas to the appropriate pan tool
    for i in range(len(canvas_list)):
        if pan_button.isChecked():
            canvas_list[i].setMapTool(dlg.pan_tools[i])
        else:
            canvas_list[i].unsetMapTool(dlg.pan_tools[i])

def swipeTool(dlg, canvas, swipe_button):
    """Enables/disables swipe tool"""

    if swipe_button.isChecked():
        dlg.swipeTool = mapswipetool.MapSwipeTool(canvas)
        canvas.setMapTool(dlg.swipeTool)
    else:
        canvas.unsetMapTool(dlg.swipeTool)

def zoomToExt(canvas_list):
    """Zooms provided canvas to extent of primary layer"""

    for canvas in canvas_list:
        active_layer = canvas.layers()[0]
        canvas.setExtent(active_layer.extent())
        canvas.refresh()

def transparency(val, canvas):
    """Changes top image transparency based on slider"""
    # not sure why this needs to be so complicated

    active_layer = canvas.layers()[0]

    raster_transparency  = active_layer.renderer().rasterTransparency()

    ltr = QgsRasterTransparency.TransparentSingleValuePixel()
    tr_list = []
    ltr.min = 0
    ltr.max = 255
    ltr.percentTransparent = val # set transparency based on slider value
    tr_list.append(ltr)

    raster_transparency.setTransparentSingleValuePixelList(tr_list)
    active_layer.triggerRepaint()
        
def changeView(full_canvas, exclusive_tools):
    """Changes display from side-by-side to one window or v-v"""

    if not full_canvas.isVisible():
        full_canvas.show()
        for tool in exclusive_tools:
            tool.setEnabled(True) # enables any tools exclusive to full view (e.g., swipe)
    else:
        full_canvas.hide()
        for tool in exclusive_tools:
            tool.setEnabled(False) # disables any tools exclusive to full view (e.g., swipe)
            tool.setChecked(False)

def changeTools(tool_list, active_tool):
    """Ensures only the active tool is checked"""

    for tool_button in tool_list:
        if tool_button != active_tool:
            tool_button.setChecked(False)
