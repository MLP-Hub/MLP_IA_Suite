# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MLP_IA_Suite
                                 A QGIS plugin
 This plugin contains an end-to-end workflow for analysing terrestrial oblique images 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-12-15
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Claire Wright | Mountain Legacy Project
        email                : claire.wright.mi@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import numpy as np
import scipy
import cv2
import skimage
import tempfile

from qgis.core import QgsRasterLayer, QgsProcessing, QgsProject
from qgis.PyQt.QtWidgets import QFileDialog
from PyQt5.QtCore import Qt
from qgis import processing

from .interface_tools import errorMessage,  loadLayer

def addLayer(filter_string, listWidget):
    """Users provides raster layer to add to list"""

    dialog = QFileDialog()
    dialog.setFileMode(QFileDialog.ExistingFiles)
    dialog.setOption(dialog.DontUseNativeDialog)
    dialog.setNameFilter(filter_string)

    if dialog.exec_():
        filepaths = dialog.selectedFiles() # get user selected file(s)
        for filepath in filepaths:
            match = listWidget.findItems(filepath,Qt.MatchExactly) # check to ensure filepath doesn't exist already
            if len(match) == 0:
                listWidget.addItem(filepath) # if not a duplicate, add filepath to list

def removeLayer(listWidget):
    """Removes selected layer from layer list"""

    row = listWidget.currentRow()
    listWidget.takeItem(row)

def readRasterLayers(listWidget):
    """Reads filepaths from list and finds extents for each layer"""

    filepaths = [listWidget.item(x).text() for x in range(listWidget.count())]

    min_xs = []
    max_xs = []
    min_ys = []
    max_ys = []

    for filepath in filepaths:
        good_path = os.path.realpath(filepath)
        raster_layer = QgsRasterLayer(good_path, os.path.basename(good_path))
        ex = raster_layer.extent()
        min_xs.append(ex.xMinimum())
        max_xs.append(ex.xMaximum())
        min_ys.append(ex.yMinimum())
        max_ys.append(ex.yMaximum())

    extents = [min_xs, max_xs, min_ys, max_ys]

    return filepaths, extents

def rankedMosaic(filepaths, extents, res_x, res_y):
    """Mosaics a set of rasters based on mode"""
    
    input_arrays = []

    for i, filepath in enumerate(filepaths):
        
        # read image into array
        img = skimage.io.imread(os.path.realpath(filepath), as_gray=True)

        # pad array with NaN values so that all inputs have same size

        before_y = int(extents[2][i-1] - min(extents[2]))
        after_y = int(max(extents[3]) - extents[3][i-1])

        before_x = int(max(extents[1]) - extents[1][i-1])
        after_x = int(extents[0][i-1] - min(extents[0]))
        
        pad_width = ((before_y, after_y), (before_x, after_x))

        img_pad = np.pad(img.astype(np.float), pad_width, mode='constant', constant_values=np.nan)

        img_pad[img_pad == 0] = np.nan # convert zeros to NaN as well

        input_arrays.append(img_pad)
    
    mosaic = scipy.stats.mode(input_arrays, axis = 0, nan_policy = 'omit')[0]
    mosaic = mosaic.astype(np.int)
    np.squeeze(mosaic)
    
    # later, account for different layer resolutions

    return mosaic

def probMosaic(filepaths, extents):
    """Mosaics a set of rasters based on classification probability"""

def createMosaicLayer(mosaic_path, extents):
    """Converts mosaic image to useable layer"""
 
    ext_list = ["-a_ullr",str(min(extents[0])),str(max(extents[3])),str(max(extents[1])), str(min(extents[2]))]
    ullr = " ".join(ext_list)

    PARAMS = { 'COPY_SUBDATASETS' : False, 
              'DATA_TYPE' : 0, 
              'EXTRA' : ullr, 
              'INPUT' : mosaic_path, 
              'NODATA' : "0", 
              'OPTIONS' : '', 
              'OUTPUT' : QgsProcessing.TEMPORARY_OUTPUT, 
              'TARGET_CRS' : None }

    mosaic_ref=processing.run("gdal:translate", PARAMS)

    mosaic_ref_path=mosaic_ref['OUTPUT']
    mosaic_layer = QgsRasterLayer(mosaic_ref_path, "Mosaic")

    return mosaic_ref_path, mosaic_layer  

def mosaicRasters(listWidget, ranking_checkBox, dlg):
    """Mosaics provided rasters together"""

    filepaths, extents = readRasterLayers(listWidget)

    if ranking_checkBox.isChecked():
        mosaic_img = rankedMosaic(filepaths, extents, 1, 1)
    else:
        mosaic_img = probMosaic(filepaths, extents)

    if mosaic_img is None:
        # break if mosaicking did not work
        errorMessage("Mosaicking failed.")
        return

    # save mosaicked image to temp path
    dlg.mosaic_path = os.path.join(tempfile.mkdtemp(), 'tempMosaic.tiff')
    if os.path.isfile(dlg.mosaic_path):
        # check if the temporary file already exists
        os.remove(dlg.mosaic_path)
    
    #skimage.io.imsave("C:\\MIAS\\ttt.tiff", mosaic_img)

    skimage.io.imsave(dlg.mosaic_path, mosaic_img) # write viewshed to image


    dlg.mosaic_path, mosaic_ref_layer = createMosaicLayer(dlg.mosaic_path, extents) # convert viewshed from image to referenced raster layer, update path to VS layer

    QgsProject.instance().addMapLayer(mosaic_ref_layer, False) # add layer to the registry (but don't load into main map)
    
    dir_path = os.path.dirname(__file__)
    dir_path = os.path.normpath(dir_path)
    style_path = os.path.join(dir_path, "sb_PyLC_style.qml") # path to file containing layer style

    mosaic_ref_layer.loadNamedStyle(style_path)

    #remove any existing layers, then add VS and DEM to map
    layer_list = dlg.Mosaic_mapCanvas.layers()
    for lyr in layer_list:
        QgsProject.instance().removeMapLayer(lyr.id()) # if the layer already exists, remove it from the canvas
    loadLayer(dlg.Mosaic_mapCanvas, mosaic_ref_layer)